學習知識  尚硅谷的尚醫通項目

mybatis-plus

p4建表语句

```sql
`CREATE TABLE `user`(
  id BIGINT (20) NOT NULL COMMENT 主键ID,
  NAME VARCHAR (30) NULL DEFAULT NULL COMMENT 姓名,
  age INT(11) NULL DEFAULT NULL COMMENT 年龄,
  email VARCHAR(50) NULL DEFAULT NULL COMMENT 邮箱,
  PRIMARY KEY (id)
)

INSERT INTO USER(id,NAME,age,email) VALUES
(1,Jone,18,test1@baomidou.com),
(2,Jack,20,test2@baomidou.com),
(3,Tom,28,test3@baomidou.com),
(4,Sandy,21,test4@baomidou.com),
(5,Billie,24,test5@baomidou.com)
```

mp的主鍵策略：

@Table(type=IdType.)

assign_id:生成19位唯一隨機值：雪花算法

assign_uuid:生成uuid的值

Auto:正增長

imput：手動set

none：手動設置

自動填充：和set相同的策略





樂觀鎖：解決問題的方案，黨進行更新的時候，兩個人進行一起操作的時候，會產生丟失更新問題

樂觀鎖主要是進行加版本號，更新之前獲得版本號，比較和數據庫裏面的版本，相同提交，提交完后進行版本號的更新。

物理刪除：真正刪除的數據

邏輯刪除：表沒刪除，但是查詢不出來了？？刪除的時候修改標志位 0 刪除，1，沒刪除



![image-20210916235208329](D:\typro截图\image-20210916235208329.png)

需求：醫院設置

```
RequestBody json傳遞數據
```

required=false值可以爲空 要和post一起用！



```java
@ControllerAdvice
```

```
    @ExceptionHandler(Exception.class)
    @ResponseBody
```

異常可以輸出


前端52-56跳过！
p59前端跳过
P62
P63导入的前端代码

dict数据库
id：id
parent id:上级iD
id   parentid   name
1       0       民族  一级
11      1       汉族   二级

@Tablefield（exist=false)
表里面不存在，直接写会报错，怎么不报错？上面的按照上面写
说明：hasChildren为树形组件所需字典，标识为数据库表不存在该字段

serviceimpl不用注入mapper，直接调用方法


操作EasyExcel操作Excel

缓存：提高查询速度，不是什么数据都可以放入缓存
适合做缓存：不经常修改，经常查询的数据，比较固定的数据 
1.加pom
2.加redisconfig类
package com.atguigu.yygh.common.config;

import com.fasterxml.jackson.annotation.JsonAutoDetect;
import com.fasterxml.jackson.annotation.PropertyAccessor;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.cache.CacheManager;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.cache.interceptor.KeyGenerator;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.cache.RedisCacheConfiguration;
import org.springframework.data.redis.cache.RedisCacheManager;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.RedisSerializationContext;
import org.springframework.data.redis.serializer.RedisSerializer;
import org.springframework.data.redis.serializer.StringRedisSerializer;

import java.lang.reflect.Method;
import java.time.Duration;

@Configuration
@EnableCaching
public class RedisConfig {

    /**
     * 自定义key规则
     * @return
     */
    @Bean
    public KeyGenerator keyGenerator() {
        return new KeyGenerator() {
            @Override
            public Object generate(Object target, Method method, Object... params) {
                StringBuilder sb = new StringBuilder();
                sb.append(target.getClass().getName());
                sb.append(method.getName());
                for (Object obj : params) {
                    sb.append(obj.toString());
                }
                return sb.toString();
            }
        };
    }

    /**
     * 设置RedisTemplate规则
     * @param redisConnectionFactory
     * @return
     */
    @Bean
    public RedisTemplate<Object, Object> redisTemplate(RedisConnectionFactory redisConnectionFactory) {
        RedisTemplate<Object, Object> redisTemplate = new RedisTemplate<>();
        redisTemplate.setConnectionFactory(redisConnectionFactory);
        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);

//解决查询缓存转换异常的问题
        ObjectMapper om = new ObjectMapper();
// 指定要序列化的域，field,get和set,以及修饰符范围，ANY是都有包括private和public
        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
// 指定序列化输入的类型，类必须是非final修饰的，final修饰的类，比如String,Integer等会跑出异常
        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
        jackson2JsonRedisSerializer.setObjectMapper(om);

//序列号key value
        redisTemplate.setKeySerializer(new StringRedisSerializer());
        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);
        redisTemplate.setHashKeySerializer(new StringRedisSerializer());
        redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);

        redisTemplate.afterPropertiesSet();
        return redisTemplate;
    }

    /**
     * 设置CacheManager缓存规则
     * @param factory
     * @return
     */
    @Bean
    public CacheManager cacheManager(RedisConnectionFactory factory) {
        RedisSerializer<String> redisSerializer = new StringRedisSerializer();
        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);

//解决查询缓存转换异常的问题
        ObjectMapper om = new ObjectMapper();
        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
        jackson2JsonRedisSerializer.setObjectMapper(om);

// 配置序列化（解决乱码的问题）,过期时间600秒
        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
                .entryTtl(Duration.ofSeconds(600))
                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer))
                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))
                .disableCachingNullValues();

        RedisCacheManager cacheManager = RedisCacheManager.builder(factory)
                .cacheDefaults(config)
                .build();
        return cacheManager;
    }

}

缓存@Cacheable
根据方法对其返回结果进行缓存，下次请求时，如果缓存存在，则直接读取缓存数据返回；如果缓存不存在，则执行方法，并把返回的结果存入缓存中。一般用在查询方法上。
查看源码，属性值如下：
属性/方法名	解释
value	缓存名，必填，它指定了你的缓存存放在哪块命名空间
cacheNames	与 value 差不多，二选一即可
key	可选属性，可以使用 SpEL 标签自定义缓存的key

缓存@CachePut
使用该注解标志的方法，每次都会执行，并将结果存入指定的缓存中。其他方法可以直接从响应的缓存中读取缓存数据，而不需要再去查询数据库。一般用在新增方法上。
查看源码，属性值如下：
属性/方法名	解释
value	缓存名，必填，它指定了你的缓存存放在哪块命名空间
cacheNames	与 value 差不多，二选一即可
key	可选属性，可以使用 SpEL 标签自定义缓存的key

缓存@CacheEvict
使用该注解标志的方法，会清空指定的缓存。一般用在更新或者删除方法上
查看源码，属性值如下：
属性/方法名	解释
value	缓存名，必填，它指定了你的缓存存放在哪块命名空间
cacheNames	与 value 差不多，二选一即可
key	可选属性，可以使用 SpEL 标签自定义缓存的key
allEntries	是否清空所有缓存，默认为 false。如果指定为 true，则方法调用后将立即清空所有的缓存
beforeInvocation	是否在方法执行前就清空，默认为 false。如果指定为 true，则在方法执行前就会清空缓存

nginx不同端口访问！！P65跳过
MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。